// GENERATED CODE - DO NOT MODIFY BY HAND
// dart format width=80

// **************************************************************************
// MCPGenerator
// **************************************************************************

// ignore_for_file: type=lint
part of 'cbn.dart';

/// Generated extension for [NGCentralBankMCPServer] that provides automatic registration
/// of all annotated MCP tools, resources, and prompts.
///
/// This code is automatically generated by the MCP Dart framework.
/// Do not modify this file directly - instead, modify the source
/// class and run `dart run build_runner build` to regenerate.
extension NGCentralBankMCPServerRegistration on NGCentralBankMCPServer {
  /// Registers all generated handlers for annotated methods.
  /// Call this method in your constructor to automatically register
  /// all MCP tools, resources, and prompts.
  void registerGeneratedHandlers() {
    // Register handler for @MCPTool('getAllCirculars')

    registerTool(
      'getAllCirculars',
      (context) async {
        final startDate = context.optionalParam<String?>('startDate');
        final endDate = context.optionalParam<String?>('endDate');
        final category = context.optionalParam<String?>('category');
        final limit = context.optionalParam<int>('limit') ?? 50;
        return await getAllCirculars(
          startDate: startDate,
          endDate: endDate,
          category: category,
          limit: limit,
        );
      },
      description:
          'Fetch all CBN circulars with optional filtering by date range and category',
      inputSchema: {
        'type': 'object',
        'properties': {
          'startDate': {
            'type': 'string',
            'description': 'Start date for filtering (YYYY-MM-DD format)',
          },
          'endDate': {
            'type': 'string',
            'description': 'End date for filtering (YYYY-MM-DD format)',
          },
          'category': {
            'type': 'string',
            'description': 'Category filter for circulars',
          },
          'limit': {
            'type': 'integer',
            'description': 'Maximum number of results to return',
          },
        },
      },
    );

    // Register handler for @MCPTool('getCircularById')

    registerTool(
      'getCircularById',
      (context) async {
        final circularId = context.param<int>('circularId');
        return await getCircularById(circularId);
      },
      description: 'Get a specific CBN circular by its ID',
      inputSchema: {
        'type': 'object',
        'properties': {
          'circularId': {
            'type': 'integer',
            'description': 'The ID of the circular to retrieve',
          },
        },
        'required': ['circularId'],
      },
    );

    // Register handler for @MCPTool('searchCirculars')

    registerTool(
      'searchCirculars',
      (context) async {
        final query = context.param<String>('query');
        final limit = context.optionalParam<int>('limit') ?? 20;
        return await searchCirculars(query: query, limit: limit);
      },
      description: 'Search CBN circulars by title or description keywords',
      inputSchema: {
        'type': 'object',
        'properties': {
          'query': {
            'type': 'string',
            'description':
                'Search query to match against circular titles and descriptions',
          },
          'limit': {
            'type': 'integer',
            'description': 'Maximum number of results to return',
          },
        },
        'required': ['query'],
      },
    );

    // Register handler for @MCPTool('fetchCircularPdf')

    registerTool(
      'fetchCircularPdf',
      (context) async {
        final pdfUrl = context.param<String>('pdfUrl');
        return await fetchCircularPdf(pdfUrl);
      },
      description:
          'Fetch the PDF content of a CBN circular by its URL (downloads binary data - use getCircularPdfUrl for LLM processing)',
      inputSchema: {
        'type': 'object',
        'properties': {
          'pdfUrl': {
            'type': 'string',
            'description': 'The URL of the PDF to fetch',
          },
        },
        'required': ['pdfUrl'],
      },
    );

    // Register handler for @MCPTool('downloadCircularPdfBinary')

    registerTool(
      'downloadCircularPdfBinary',
      (context) async {
        final circularId = context.param<int>('circularId');
        return await downloadCircularPdfBinary(circularId);
      },
      description:
          'Download the full PDF binary content (legacy - not recommended for LLM use)',
      inputSchema: {
        'type': 'object',
        'properties': {
          'circularId': {
            'type': 'integer',
            'description': 'The ID of the circular whose PDF to download',
          },
        },
        'required': ['circularId'],
      },
    );

    // Register handler for @MCPTool('fetchCircularPdfById')

    registerTool(
      'fetchCircularPdfById',
      (context) async {
        final circularId = context.param<int>('circularId');
        return await fetchCircularPdfById(circularId);
      },
      description:
          'Get PDF information and download URL for a CBN circular by its ID (LLM-friendly)',
      inputSchema: {
        'type': 'object',
        'properties': {
          'circularId': {
            'type': 'integer',
            'description': 'The ID of the circular whose PDF info to fetch',
          },
        },
        'required': ['circularId'],
      },
    );

    // Register handler for @MCPTool('getCircularPdfUrl')

    registerTool(
      'getCircularPdfUrl',
      (context) async {
        final circularId = context.param<int>('circularId');
        return await getCircularPdfUrl(circularId);
      },
      description:
          'Get the direct download URL for a CBN circular PDF by its ID',
      inputSchema: {
        'type': 'object',
        'properties': {
          'circularId': {
            'type': 'integer',
            'description': 'The ID of the circular whose PDF URL to get',
          },
        },
        'required': ['circularId'],
      },
    );

    // Register handler for @MCPTool('getCircularsForLLMAnalysis')

    registerTool(
      'getCircularsForLLMAnalysis',
      (context) async {
        final limit = context.optionalParam<int>('limit') ?? 5;
        final includePdfUrls =
            context.optionalParam<bool>('includePdfUrls') ?? true;
        return await getCircularsForLLMAnalysis(
          limit: limit,
          includePdfUrls: includePdfUrls,
        );
      },
      description:
          'Get recent CBN circulars with PDF URLs formatted for LLM analysis',
      inputSchema: {
        'type': 'object',
        'properties': {
          'limit': {
            'type': 'integer',
            'description': 'Number of recent circulars to get',
          },
          'includePdfUrls': {
            'type': 'boolean',
            'description': 'Include PDF URLs for direct LLM access',
          },
        },
      },
    );

    // Register handler for @MCPResource('cbnApiStatus')

    registerResource('cbnApiStatus', (uri) async {
      final result = await getCBNApiStatus();
      return MCPResourceContent(
        uri: uri,
        name: 'cbnApiStatus',
        mimeType: 'application/json',
        text: jsonEncode(result),
      );
    });

    // Register handler for @MCPResource('serverInfo')

    registerResource('serverInfo', (uri) async {
      final result = await getServerInfo();
      return MCPResourceContent(
        uri: uri,
        name: 'serverInfo',
        mimeType: 'application/json',
        text: jsonEncode(result),
      );
    });

    // Register handler for @MCPResource('availableCircularPdfs')

    registerResource('availableCircularPdfs', (uri) async {
      final result = await getAvailableCircularPdfs();
      return MCPResourceContent(
        uri: uri,
        name: 'availableCircularPdfs',
        mimeType: 'application/json',
        text: jsonEncode(result),
      );
    });

    // Register handler for @MCPPrompt('circularSummary')

    registerPrompt('circularSummary', (args) {
      final circularData = args['circularData'] as String;
      final summaryType = args['summaryType'] as String? ?? 'general';
      return circularSummaryPrompt(
        circularData: circularData,
        summaryType: summaryType,
      );
    });

    // Register handler for @MCPPrompt('regulatoryAnalysis')

    registerPrompt('regulatoryAnalysis', (args) {
      final circulars = args['circulars'] as String;
      final institutionType =
          args['institutionType'] as String? ?? 'financial institution';
      return regulatoryAnalysisPrompt(
        circulars: circulars,
        institutionType: institutionType,
      );
    });

    // Register handler for @MCPTool('getAllExchangeRates')

    registerTool(
      'getAllExchangeRates',
      (context) async {
        final startDate = context.optionalParam<String?>('startDate');
        final endDate = context.optionalParam<String?>('endDate');
        final currency = context.optionalParam<String?>('currency');
        final limit = context.optionalParam<int>('limit') ?? 50;
        return await getAllExchangeRates(
          startDate: startDate,
          endDate: endDate,
          currency: currency,
          limit: limit,
        );
      },
      description: 'Fetch all CBN exchange rates with optional filtering',
      inputSchema: {
        'type': 'object',
        'properties': {
          'startDate': {
            'type': 'string',
            'description': 'Start date for filtering (YYYY-MM-DD format)',
          },
          'endDate': {
            'type': 'string',
            'description': 'End date for filtering (YYYY-MM-DD format)',
          },
          'currency': {
            'type': 'string',
            'description': 'Currency for filtering',
          },
          'limit': {'type': 'integer', 'description': 'Limit for filtering'},
        },
      },
    );

    // Register handler for @MCPTool('getExchangeRateById')

    registerTool(
      'getExchangeRateById',
      (context) async {
        final exchangeRateId = context.param<int>('exchangeRateId');
        return await getExchangeRateById(exchangeRateId);
      },
      description: 'Get a specific CBN exchange rate by its ID',
      inputSchema: {
        'type': 'object',
        'properties': {
          'exchangeRateId': {
            'type': 'integer',
            'description': 'The ID of the exchange rate to retrieve',
          },
        },
        'required': ['exchangeRateId'],
      },
    );

    // Register handler for @MCPTool('getAllFinancialData')

    registerTool(
      'getAllFinancialData',
      (context) async {
        final startDate = context.optionalParam<String?>('startDate');
        final endDate = context.optionalParam<String?>('endDate');
        final limit = context.optionalParam<int>('limit') ?? 50;
        final minOpeningBalance = context.optionalParam<double?>(
          'minOpeningBalance',
        );
        final maxOpeningBalance = context.optionalParam<double?>(
          'maxOpeningBalance',
        );
        final minRepo = context.optionalParam<double?>('minRepo');
        final maxRepo = context.optionalParam<double?>('maxRepo');
        final minCashReserveRatio = context.optionalParam<double?>(
          'minCashReserveRatio',
        );
        final maxCashReserveRatio = context.optionalParam<double?>(
          'maxCashReserveRatio',
        );
        return await getAllFinancialData(
          startDate: startDate,
          endDate: endDate,
          limit: limit,
          minOpeningBalance: minOpeningBalance,
          maxOpeningBalance: maxOpeningBalance,
          minRepo: minRepo,
          maxRepo: maxRepo,
          minCashReserveRatio: minCashReserveRatio,
          maxCashReserveRatio: maxCashReserveRatio,
        );
      },
      description: 'Fetch all CBN financial data with optional filtering',
      inputSchema: {
        'type': 'object',
        'properties': {
          'startDate': {
            'type': 'string',
            'description': 'Start date for filtering (YYYY-MM-DD format)',
          },
          'endDate': {
            'type': 'string',
            'description': 'End date for filtering (YYYY-MM-DD format)',
          },
          'limit': {'type': 'integer', 'description': 'Limit for filtering'},
          'minOpeningBalance': {
            'type': 'string',
            'description': 'Min opening balance for filtering',
          },
          'maxOpeningBalance': {
            'type': 'string',
            'description': 'Max opening balance for filtering',
          },
          'minRepo': {
            'type': 'string',
            'description': 'Min repo for filtering',
          },
          'maxRepo': {
            'type': 'string',
            'description': 'Max repo for filtering',
          },
          'minCashReserveRatio': {
            'type': 'string',
            'description': 'Min cash reserve ratio for filtering',
          },
          'maxCashReserveRatio': {
            'type': 'string',
            'description': 'Max cash reserve ratio for filtering',
          },
        },
      },
    );

    // Register handler for @MCPTool('getFinancialDataById')

    registerTool(
      'getFinancialDataById',
      (context) async {
        final financialDataId = context.param<int>('financialDataId');
        return await getFinancialDataById(financialDataId);
      },
      description: 'Get a specific CBN financial data by its ID',
      inputSchema: {
        'type': 'object',
        'properties': {
          'financialDataId': {
            'type': 'integer',
            'description': 'The ID of the financial data to retrieve',
          },
        },
        'required': ['financialDataId'],
      },
    );

    // Register handler for @MCPResource('randomFact')

    registerResource('randomFact', (uri) async {
      final result = await getRandomFact();
      return MCPResourceContent(
        uri: uri,
        name: 'randomFact',
        mimeType: 'application/json',
        text: jsonEncode(result),
      );
    });
  }

  /// Generates standardized usage documentation for MCP servers.
  ///
  /// This helper method provides consistent help text formatting
  /// for this specific MCP server with its available capabilities.
  void showUsage({String? serverName}) {
    print('Usage: dart ${serverName ?? "server"}.dart [options]');
    print('');
    print('Options:');
    print('  --stdio        Start server in stdio mode (default)');
    print('  --http         Start HTTP server on port 8080');
    print('  --port <port>  Specify HTTP port (default: 8080)');
    print('  --help, -h     Show this help message');
    print('');
    print(
      'Available tools: getAllCirculars, getCircularById, searchCirculars, fetchCircularPdf, downloadCircularPdfBinary, fetchCircularPdfById, getCircularPdfUrl, getCircularsForLLMAnalysis, getAllExchangeRates, getExchangeRateById, getAllFinancialData, getFinancialDataById',
    );
    print(
      'Available resources: cbnApiStatus, serverInfo, availableCircularPdfs, randomFact',
    );
    print('Available prompts: circularSummary, regulatoryAnalysis');
    print('');

    print('Examples:');
    print('  dart ${serverName ?? "server"}.dart');
    print('  dart ${serverName ?? "server"}.dart --http');
    print('  dart ${serverName ?? "server"}.dart --http --port 3000');
  }
}
